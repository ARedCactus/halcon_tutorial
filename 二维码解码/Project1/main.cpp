///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 21.11.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  include <iostream>
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#    include <HALCON/HpThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#    include <HALCONxl/HpThread.h>
#  endif
#  include <stdio.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif


using namespace std;
using namespace HalconCpp;

// Procedure declarations 
// Chapter: File / Misc
// Short Description: Get all image files under the given path 
extern void list_image_files (HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options, 
    HTuple *hv_ImageFiles);
// Local procedures 
void display_found_data_codes (HObject ho_SymbolXLDs, HTuple hv_WindowHandle, HTuple hv_DecodedDataStrings, 
    HTuple hv_TitleMessage, HTuple hv_ResultMessage, HTuple hv_ColorDecodedStrings, 
    HTuple hv_ColorResult);

// Procedures 
// Local procedures 
void display_found_data_codes (HObject ho_SymbolXLDs, HTuple hv_WindowHandle, HTuple hv_DecodedDataStrings, 
    HTuple hv_TitleMessage, HTuple hv_ResultMessage, HTuple hv_ColorDecodedStrings, 
    HTuple hv_ColorResult)
{

  // Local iconic variables
  HObject  ho_SymbolXLD;

  // Local control variables
  HTuple  hv_J, hv_Row, hv_Column, hv_Row1, hv_Column1;
  HTuple  hv_Width, hv_Height, hv_Ascent, hv_Descent, hv_TWidth;
  HTuple  hv_THeight, hv_DecodedData, hv_DecodedDataSubstrings;
  HTuple  hv_TPosRow, hv_TPosColumn;

  //This procedure displays the results of the search for
  //2d data codes. The data strings are displayed accordingly
  //to their length so that the whole string is visible.
  //If the data strings are too long only the first 50 chars
  //are displayed.

  //Input parameters are the XLD contours of the decoded
  //data symbols, the decoded data strings, the windowhandle,
  //a title message, a result message, the color of the decoded
  //strings and the color of the result message.

  //Display the result of the search for each found data code.
  {
  HTuple end_val12 = (hv_DecodedDataStrings.TupleLength())-1;
  HTuple step_val12 = 1;
  for (hv_J=0; hv_J.Continue(end_val12, step_val12); hv_J += step_val12)
  {

    //Display the XLD contour.
    SelectObj(ho_SymbolXLDs, &ho_SymbolXLD, hv_J+1);
    GetContourXld(ho_SymbolXLD, &hv_Row, &hv_Column);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_SymbolXLD, HDevWindowStack::GetActive());

    //Display messages.
    //------------------
    //Determine the length of the dislayed decoded data string.
    GetWindowExtents(hv_WindowHandle, &hv_Row1, &hv_Column1, &hv_Width, &hv_Height);
    GetStringExtents(hv_WindowHandle, HTuple(hv_DecodedDataStrings[hv_J]), &hv_Ascent, 
        &hv_Descent, &hv_TWidth, &hv_THeight);
    if (0 != (int(hv_TWidth>hv_Width)))
    {
      hv_DecodedDataStrings[hv_J] = (HTuple(hv_DecodedDataStrings[hv_J]).TupleSubstr(0,50))+"...";
      GetStringExtents(hv_WindowHandle, HTuple(hv_DecodedDataStrings[hv_J]), &hv_Ascent, 
          &hv_Descent, &hv_TWidth, &hv_THeight);
    }

    //Split the decoded string in new lines for better readability.
    TupleRegexpReplace(HTuple(hv_DecodedDataStrings[hv_J]), (HTuple("[\\r\\f,^#;]").Append("replace_all")), 
        "\n", &hv_DecodedData);
    TupleSplit(hv_DecodedData, "\n", &hv_DecodedDataSubstrings);

    //Determine the position of the displayed decoded data string.
    if (0 != (HTuple(int((hv_Row.TupleMax())>420)).TupleAnd(int((hv_Row.TupleMin())<40))))
    {
      hv_TPosRow = (hv_Row.TupleMax())-30;
    }
    else if (0 != (int((hv_Row.TupleMax())>420)))
    {
      hv_TPosRow = (hv_Row.TupleMin())-20;
    }
    else if (0 != (int((hv_Row.TupleMin())<100)))
    {
      hv_TPosRow = (hv_Row.TupleMax())-20;
    }
    else
    {
      hv_TPosRow = (hv_Row.TupleMax())-30;
    }
    hv_TPosColumn = (((((hv_Column.TupleMean())-(hv_TWidth/2)).TupleConcat((hv_Width-32)-hv_TWidth)).TupleMin()).TupleConcat(12)).TupleMax();
    if (HDevWindowStack::IsOpen())
      DispText(HDevWindowStack::GetActive(),HTuple(hv_DecodedDataStrings[hv_J]), 
          "image", hv_TPosRow, hv_TPosColumn, hv_ColorDecodedStrings, HTuple(), HTuple());
  }
  }

  //Display the title message and result message.
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_TitleMessage, "window", 12, 12, "black", 
        HTuple(), HTuple());
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),hv_ResultMessage, "window", 40, 12, hv_ColorResult, 
        HTuple(), HTuple());
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_image, ho_SymbolXLDs;

  // Local control variables
  HTuple  hv_Handle, hv_ImageFiles, hv_I, hv_ResultHandles;
  HTuple  hv_DecodedDataStrings;

  CreateDataCode2dModel("QR Code", HTuple(), HTuple(), &hv_Handle);
  list_image_files("files", "default", HTuple(), &hv_ImageFiles);
  {
  HTuple end_val2 = (hv_ImageFiles.TupleLength())-1;
  HTuple step_val2 = 1;
  for (hv_I=0; hv_I.Continue(end_val2, step_val2); hv_I += step_val2)
  {
    ReadImage(&ho_image, HTuple(hv_ImageFiles[hv_I]));
    FindDataCode2d(ho_image, &ho_SymbolXLDs, hv_Handle, HTuple(), HTuple(), &hv_ResultHandles, 
        &hv_DecodedDataStrings);
  }
  }


  cout<< hv_DecodedDataStrings;
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
static HMutex*     sStartMutex;
static H_pthread_t sActionThread;
static bool        sTerminate = false;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  sStartMutex->UnlockMutex();
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  sStartMutex->LockMutex();
  sStartMutex->UnlockMutex();

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            exception.ProcName().TextA(),
            exception.ErrorMessage().TextA());
  }

  // Tell the main thread to terminate itself.
  sStartMutex->LockMutex();
  sTerminate = true;
  sStartMutex->UnlockMutex();
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  sStartMutex = new HMutex("type","sleep");
  sStartMutex->LockMutex();

  error = HpThreadHandleAlloc(&sActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(sActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    bool terminate;

    CFRunLoopRun();

    sStartMutex->LockMutex();
    terminate = sTerminate;
    sStartMutex->UnlockMutex();

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(sActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  delete sStartMutex;
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#endif

    // file was stored with local-8-bit encoding
    //   -> set the interface encoding accordingly
    SetHcppInterfaceStringEncodingIsUtf8(false);

    // Default settings used in HDevelop (can be omitted)
    SetSystem("width", 512);
    SetSystem("height", 512);

#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            exception.ProcName().TextA(),
            exception.ErrorMessage().TextA());
    ret = 1;
  }
  return ret;
}

#endif


#endif


